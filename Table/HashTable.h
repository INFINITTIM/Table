#pragma once

#include "Record.h"
#include "Table.h"

template <typename TKey, typename TVal>
class HashTable : public Table<TKey, TVal>
{
protected:
	int size;
public:
	HashTable(int _size = 10) : Table<TKey, TVal>(), size(_size) {}
	virtual int HashFunction(TKey key)
	{
		return key % size;
	}
};

// хэш-таблицы
// как может подпрограмма (хэш-функци€) работать?
// у нас есть запись а у неЄ ключ и значение нужна функци€ котора€ будет по ключу сообщать где
// эта функци€ должна находитьс€. int HashFunc(TKey); где можно использовать ключ как номер
// множество ключей намного больше чем кол-во возможных записей 
// 
// ----------------    return key%size; но тогда может произойти коллизи€
// |              |    может организовать хэш-функцию как суммирование всех ключей в строке
// |              |    int HashFunc(TKey)
// |              |    {
// |              |			int res = 0;
// |              |         for (int i = 0; i < key.length(); i++)
// |              |				res += key[i];   // res += key[i]*(i+1);
// |              |         return res%size;
// |              |    } 
// |              |
// ----------------  элементами этой таблицы может быть не ключ-значение 
// а списки то есть получитс€ массив списков
// в худшем случае хэш таблица дас линейную трудоЄмкость 
// если сделать return 1 и будет линейный список
// 
// предположим что у нас нет такой сущности как дополнительные списки
// если не произошла коллизи€ то можем применить вторичное хэширование 
// если запись приходит и ее место зан€то то мы можем записать ее с некоторым смещением 
// размер шага должен быть взаимно-простым относительно размера таблицы 
// 
// вводитс€ пон€тие пуста€ €чейка (свободна€) при поиске ключа мы идем до обнаружени€ ключа
// или до пустой €чейки
// 
// дл€ организации вторичного хэшировани€ нужно пон€тие свободна€ €чейка 
// 
// так же вводим пон€тие удаленна€ €чейка чтобы не прервалось при удалении и замене записи
// на пустую €чейку 
//